// 备份当前的 Lexer.hx 内容
package pyscript.core;

import pyscript.utils.Token;
import pyscript.utils.TokenType;

/**
 * Python词法分析器
 */
class Lexer {
    // 词法分析器状态
    var source:String;        // 源代码
    var position:Int;         // 当前位置
    var line:Int;            // 当前行号
    var column:Int;          // 当前列号
    var tokens:Array<Token>; // 已生成的标记
    var start:Int;           // 当前标记起始位置
    
    // 缩进处理
    var indentStack:Array<Int>; // 缩进级别栈
    var currentIndent:Int;      // 当前缩进级别
    var atLineStart:Bool;       // 是否在行首
    
    function new(?source:String) {
        if(source != null) {
            setSource(source);
        } else {
            reset();
        }
    }
    
    function setSource(source:String):Void {
        this.source = source;
        reset();
    }

    function reset():Void {
        position = 0;
        start = 0;
        line = 1;
        column = 1;
        tokens = [];
        indentStack = [0];
        currentIndent = 0;
        atLineStart = true;
    }
    
    function isAtEnd():Bool {
        return position >= source.length;
    }
    
    function peek():String {
        if(isAtEnd()) return "";
        return source.charAt(position);
    }
    
    function peekNext():String {
        if(position + 1 >= source.length) return "";
        return source.charAt(position + 1);
    }
    
    function peekPrev():String {
        if(position - 1 < 0) return "";
        return source.charAt(position - 1);
    }
    
    function advance():String {
        if(isAtEnd()) return "";
        var char = source.charAt(position);
        position++;
        column++;
        return char;
    }
    
    function match(expected:String):Bool {
        if(isAtEnd() || source.charAt(position) != expected) return false;
        position++;
        column++;
        return true;
    }
    
    function makeToken(type:TokenType, ?value:Dynamic):Token {
        var text = source.substring(start, position);
        var token = new Token(type, value != null ? value : text, line, column - text.length);
        start = position;
        return token;
    }
    
    function tokenize():Array<Token> {
        while (!isAtEnd()) {
            start = position;
            
            try {
                // 处理行首缩进
                if (atLineStart) {
                    handleIndentation();
                    atLineStart = false;
                    if (isAtEnd()) break;
                }
                
                skipWhitespace();
                if (isAtEnd()) break;
                
                var char = peek();
                
                if (isDigit(char)) {
                    scanNumber();
                } else if (isAlpha(char) || char == "_") {
                    scanIdentifier();
                } else {
                    scanToken();
                }
                
            } catch (e:Dynamic) {
                error('${e} at line ${line}, column ${column}');
            }
        }
        
        // 处理文件结束时的缩进
        while (indentStack.length > 1) {
            tokens.push(makeToken(TokenType.DEDENT));
            indentStack.pop();
        }
        
        tokens.push(makeToken(TokenType.EOF));
        return tokens;
    }
    
    function handleIndentation():Void {
        var indent = 0;
        var tempPos = position;
        var mixedIndent = false;
        var spacesSeen = false;
        var tabsSeen = false;
        
        // 计算缩进
        while (tempPos < source.length) {
            var c = source.charAt(tempPos);
            
            if (c == " ") {
                if (tabsSeen) mixedIndent = true;
                spacesSeen = true;
                indent++;
            } else if (c == "\t") {
                if (spacesSeen) mixedIndent = true;
                tabsSeen = true;
                indent += 8; // Python的制表符等于8个空格
            } else {
                break;
            }
            tempPos++;
        }
        
        if (mixedIndent) {
            error("Mixed indentation");
        }
        
        position = tempPos;
        column += (tempPos - position);
        
        // 处理缩进级别变化
        if (indent > currentIndent) {
            indentStack.push(indent);
            tokens.push(makeToken(TokenType.INDENT));
        } else while (indent < currentIndent && indentStack.length > 1) {
            indentStack.pop();
            tokens.push(makeToken(TokenType.DEDENT));
            currentIndent = indentStack[indentStack.length - 1];
            
            if (indent > currentIndent) {
                error("Unindent does not match any outer indentation level");
            }
        }
        
        currentIndent = indent;
    }
    
    function skipWhitespace():Void {
        while (!isAtEnd()) {
            var c = peek();
            switch (c) {
                case " ", "\r", "\t":
                    advance();
                case "#":
                    while (!isAtEnd() && peek() != "\n") advance();
                default:
                    return;
            }
        }
    }
    
    function scanToken():Void {
        var c = advance();
        
        switch(c) {
            case "(": tokens.push(makeToken(TokenType.LPAREN));
            case ")": tokens.push(makeToken(TokenType.RPAREN));
            case "[": tokens.push(makeToken(TokenType.LBRACKET));
            case "]": tokens.push(makeToken(TokenType.RBRACKET));
            case "{": tokens.push(makeToken(TokenType.LBRACE));
            case "}": tokens.push(makeToken(TokenType.RBRACE));
            case ",": tokens.push(makeToken(TokenType.COMMA));
            case ".": tokens.push(makeToken(TokenType.DOT));
            case ":": tokens.push(makeToken(TokenType.COLON));
            case ";": tokens.push(makeToken(TokenType.SEMICOLON));
            case "@": tokens.push(makeToken(TokenType.AT));
            
            case "+": tokens.push(makeToken(match("=") ? TokenType.PLUS_ASSIGN : TokenType.PLUS));
            case "-": tokens.push(makeToken(match("=") ? TokenType.MINUS_ASSIGN : TokenType.MINUS));
            case "*": scanStar();
            case "/": scanSlash();
            case "%": tokens.push(makeToken(match("=") ? TokenType.MODULO_ASSIGN : TokenType.MODULO));
            case "!": tokens.push(makeToken(match("=") ? TokenType.NOT_EQUALS : TokenType.NOT));
            case "=": tokens.push(makeToken(match("=") ? TokenType.EQUALS : TokenType.ASSIGN));
            case "<": scanLess();
            case ">": scanGreater();
            
            case '"', "'": scanString(c);
            case "#": skipComment();
            case "\n": handleNewline();
            
            case " ", "\r", "\t": // 忽略
            
            default:
                error('Unexpected character "${c}"');
        }
    }
    
    function scanStar():Void {
        if (match("*")) {
            tokens.push(makeToken(match("=") ? TokenType.POWER_ASSIGN : TokenType.POWER));
        } else {
            tokens.push(makeToken(match("=") ? TokenType.MULTIPLY_ASSIGN : TokenType.MULTIPLY));
        }
    }
    
    function scanSlash():Void {
        if (match("/")) {
            tokens.push(makeToken(match("=") ? TokenType.FLOOR_DIVIDE_ASSIGN : TokenType.FLOOR_DIVIDE));
        } else {
            tokens.push(makeToken(match("=") ? TokenType.DIVIDE_ASSIGN : TokenType.DIVIDE));
        }
    }
    
    function scanLess():Void {
        if (match("=")) {
            tokens.push(makeToken(TokenType.LESS_EQUAL));
        } else if (match("<")) {
            tokens.push(makeToken(match("=") ? TokenType.LSHIFT_ASSIGN : TokenType.LSHIFT));
        } else {
            tokens.push(makeToken(TokenType.LESS));
        }
    }
    
    function scanGreater():Void {
        if (match("=")) {
            tokens.push(makeToken(TokenType.GREATER_EQUAL));
        } else if (match(">")) {
            tokens.push(makeToken(match("=") ? TokenType.RSHIFT_ASSIGN : TokenType.RSHIFT));
        } else {
            tokens.push(makeToken(TokenType.GREATER));
        }
    }
    
    function scanString(quote:String):Void {
        var triple = false;
        
        // 检查是否是三引号字符串
        if (peek() == quote && peekNext() == quote) {
            advance();
            advance();
            triple = true;
        }
        
        while (!isAtEnd()) {
            var c = peek();
            
            if (c == quote) {
                if (triple) {
                    if (peekNext() == quote && source.charAt(position + 2) == quote) {
                        advance();
                        advance();
                        advance();
                        break;
                    }
                } else {
                    advance();
                    break;
                }
            } else if (c == "\\") {
                advance();
                if (!isAtEnd()) {
                    advance();
                }
            } else if (c == "\n") {
                if (!triple) {
                    error("Unterminated string");
                }
                line++;
                column = 1;
                advance();
            } else {
                advance();
            }
        }
        
        if (isAtEnd()) {
            error("Unterminated string");
        }
        
        var value = source.substring(start + (triple ? 3 : 1), position - (triple ? 3 : 1));
        tokens.push(makeToken(TokenType.STRING, value));
    }
    
    function handleNewline():Void {
        line++;
        column = 1;
        atLineStart = true;
        
        // 忽略连续的空行
        var emptyLine = true;
        var pos = position;
        
        while (pos < source.length) {
            var c = source.charAt(pos);
            if (c == " " || c == "\t" || c == "\r") {
                pos++;
                continue;
            }
            if (c == "#") {
                while (pos < source.length && source.charAt(pos) != "\n") pos++;
                break;
            }
            if (c != "\n") {
                emptyLine = false;
            }
            break;
        }
        
        if (!emptyLine) {
            tokens.push(makeToken(TokenType.NEWLINE));
        }
    }
    
    function skipComment():Void {
        while (!isAtEnd() && peek() != "\n") {
            advance();
        }
    }
    
    function scanNumber():Void {
        var isFloat = false;
        var isScientific = false;
        var base = 10;
        
        // 检查进制前缀
        if (peekPrev() == "0") {
            switch(peek().toLowerCase()) {
                case "b": // 二进制
                    advance();
                    base = 2;
                case "o": // 八进制
                    advance(); 
                    base = 8;
                case "x": // 十六进制
                    advance();
                    base = 16;
            }
        }
        
        while (!isAtEnd()) {
            var c = peek();
            
            if (base == 16) {
                if (!(isDigit(c) || (c >= "a" && c <= "f") || (c >= "A" && c <= "F"))) {
                    break;
                }
            } else if (base == 8) {
                if (c < "0" || c > "7") break;
            } else if (base == 2) {
                if (c != "0" && c != "1") break;
            } else {
                if (c == ".") {
                    if (isFloat) break;
                    isFloat = true;
                } else if (c.toLowerCase() == "e") {
                    if (isScientific) break;
                    isScientific = true;
                    isFloat = true;
                    advance();
                    if (peek() == "-" || peek() == "+") advance();
                    if (!isDigit(peek())) {
                        error("Invalid scientific notation");
                    }
                    continue;
                } else if (!isDigit(c)) {
                    break;
                }
            }
            advance();
        }
        
        var value = source.substring(start, position);
        var number:Dynamic;
        
        try {
            if (isFloat) {
                number = Std.parseFloat(value);
            } else {
                number = switch(base) {
                    case 2: Std.parseInt("0b" + value.substr(2));
                    case 8: Std.parseInt("0o" + value.substr(2));
                    case 16: Std.parseInt("0x" + value.substr(2));
                    default: Std.parseInt(value);
                }
            }
        } catch(e:Dynamic) {
            error("Invalid number format");
        }
        
        tokens.push(makeToken(isFloat ? TokenType.FLOAT : TokenType.INT, number));
    }
    
    function scanIdentifier():Void {
        while (isAlphaNumeric(peek()) || peek() == "_") {
            advance();
        }
        
        var text = source.substring(start, position);
        var type = switch(text) {
            case "None": TokenType.NONE;
            case "True": TokenType.TRUE;
            case "False": TokenType.FALSE;
            
            case "if": TokenType.IF;
            case "elif": TokenType.ELIF;
            case "else": TokenType.ELSE;
            case "while": TokenType.WHILE;
            case "for": TokenType.FOR;
            case "break": TokenType.BREAK;
            case "continue": TokenType.CONTINUE;
            case "return": TokenType.RETURN;
            case "pass": TokenType.PASS;
            
            case "try": TokenType.TRY;
            case "except": TokenType.EXCEPT;
            case "finally": TokenType.FINALLY;
            case "raise": TokenType.RAISE;
            case "assert": TokenType.ASSERT;
            
            case "class": TokenType.CLASS;
            case "def": TokenType.DEF;
            case "lambda": TokenType.LAMBDA;
            
            case "import": TokenType.IMPORT;
            case "from": TokenType.FROM;
            case "as": TokenType.AS;
            
            case "global": TokenType.GLOBAL;
            case "nonlocal": TokenType.NONLOCAL;
            
            case "and": TokenType.AND;
            case "or": TokenType.OR;
            case "not": TokenType.NOT;
            case "in": TokenType.IN;
            case "is": TokenType.IS;
            
            case "with": TokenType.WITH;
            case "async": TokenType.ASYNC;
            case "await": TokenType.AWAIT;
            case "yield": TokenType.YIELD;
            
            case "del": TokenType.DEL;
            
            default: TokenType.IDENTIFIER;
        }
        
        tokens.push(makeToken(type));
    }
    
    function isDigit(c:String):Bool {
        return c >= "0" && c <= "9";
    }
    
    function isAlpha(c:String):Bool {
        return (c >= "a" && c <= "z") || (c >= "A" && c <= "Z") || c == "_";
    }
    
    function isAlphaNumeric(c:String):Bool {
        return isAlpha(c) || isDigit(c);
    }
    
    function error(message:String):Void {
        throw message;
    }
}
